(* end of statement terminal *)
T = ';';

variable_name = IDENTIFIER;
function_name = IDENTIFIER;
binary_operator = AND | OR | GT | LT | ADD | SUB | MUL | DIV | MOD | GE | LE | EE | NE;
literal = INTEGER | BOOLEAN;

(* Variable *)
variable_declaration = LET, variable_name, [EQ, expression];
variable_assignment = variable_name, EQ, expression;
floor_assignment = floor_access, EQ, expression;

(* Expression *)
expression = binary_expression | unary_expression;

(* Left recursion *)
binary_expression = (binary_expression | unary_expression), binary_operator, (binary_expression | unary_expression);
unary_expression = primary_expression | increment_expression | decrement_expression | NOT, expression | ADD, expression | SUB, expression;
increment_expression = ADDADD, variable_name;
decrement_expression = SUBSUB, variable_name;
floor_access = FLOOR, '[', expression ,']';
(* invocation_expression and variable_name has FIRST/FIRST conflict *)
primary_expression = literal | parenthesized_expression | invocation_expression | variable_name | floor_access;
return_statement = RETURN, [expression], T;
parenthesized_expression = '(', expression, ')';
invocation_expression = function_name,  '(', [function_argument], ')';
function_argument = expression;



(* Statement *)
empty_statement = T;
variable_declaration_statement = variable_declaration, T;
variable_assignment_statement = variable_assignment, T;
floor_assignment_statement = floor_assignment, T;
statement_block = '{', {statement}, '}';
statement = variable_declaration_statement | variable_assignment_statement | floor_assignment_statement | embedded_statement;
embedded_statement = statement_block | empty_statement | expression | iteration_statement | selection_statement | return_statement;
selection_statement = if_statement;
if_statement = IF, '(', expression, ')', embedded_statement, [ELSE, embedded_statement];
iteration_statement = while_statement | for_statement;
while_statement = WHILE, '(', expression, ')', embedded_statement;
for_statement = FOR, '(', [variable_assignment | variable_declaration], ',', [expression], ',' , [expression], ')', embedded_statement;
return_statement = RETURN, [expression], T;
(* floor init only appear outside the functions. usually at the beginning of the file *)
floor_box_init_statement = INIT, FLOOR, '[', INTEGER, ']', EQ, INTEGER, T;
(* only one floor max allowed in a program *)
floor_max_init_statement = INIT, FLOORMAX, EQ, INTEGER, T;

(* Function and subprocedure *)
function_definition = function_header, function_body;
subproc_definition = subproc_header, function_body;
(* Only one or zero param allowed now *)
formal_parameter_list = IDENTIFIER;
function_header = FUNCTION, function_name, '(', [formal_parameter_list], ')';
subproc_header = SUBWORD, function_name, '(', [formal_parameter_list], ')';
function_body = statement_block;

(* Compilation Unit *)
import_directive = IMPORT, IDENTIFIER, T;
compilation_unit_nonordered = {import_directive | variable_declaration_statement | function_definition | subproc_definition | floor_box_init_statement};
compilation_unit = compilation_unit_nonordered, [floor_max_init_statement], compilation_unit_nonordered;